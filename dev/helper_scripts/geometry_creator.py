import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull


def _export_vtk(filename, vertices, panels):
    # Exports the vertices and panel data to a VTK file.

    # Check extension
    if '.vtk' not in filename:
        raise IOError("Filename for VTK export must contain .vtk extension.")

    # Open file
    with open(filename, 'w') as export_handle:
        
        # Write header
        print("# vtk DataFile Version 3.0", file=export_handle)
        print("MachLine geometry file. Generated by MachLine Geometry Creator, USU AeroLab (c) 2022.", file=export_handle)
        print("ASCII", file=export_handle)

        # Write dataset
        print("DATASET POLYDATA", file=export_handle)

        # Write vertices
        print("POINTS {0} float".format(len(vertices)), file=export_handle)
        for vertex in vertices:
            print("{0:<20.12}{1:<20.12}{2:<20.12}".format(*vertex), file=export_handle)

        # Determine polygon list size
        N_panels = panels.shape[0]
        size = N_panels*4

        # Write panel polygons
        print("POLYGONS {0} {1}".format(N_panels, size), file=export_handle)
        for panel in panels:
            print("3 "+" ".join([str(i) for i in panel]), file=export_handle)

        # Write cell header
        print("CELL_DATA {0}".format(len(panels)), file=export_handle)

        # Write normals
        print("NORMALS normals float", file=export_handle)
        for panel in panels:
            n = np.cross(vertices[panel[1]]-vertices[panel[0]], vertices[panel[2]]-vertices[panel[1]])
            n /= np.linalg.norm(n)
            print(" ".join([str(ni) for ni in n]), file=export_handle)
            

def _get_regular_points_and_panels_for_closed_right_cone(h, r, N_transverse, N_theta, N_radial):
    # Generates the points and panels for half of a closed right cone, aligned with the x-axis and its base at the origin.
    # resultant mesh should be mirrored about the xy plane.

    # Determine number of vertices
    N_verts = 1 + N_transverse*(N_theta+1) + (N_radial-1)*(N_theta+1) + 1

    # Determine number of panels
    N_panels = (2*(N_transverse-1)+1)*N_theta + (2*(N_radial-1)+1)*N_theta

    # Initialize storage
    vertices = np.zeros((N_verts,3))
    panels = np.zeros((N_panels,3), dtype=int)

    # Apex
    vertices[0,0] = h

    # Generate distribution of locations in x, r, and theta
    X = np.linspace(h, 0.0, N_transverse+1)
    R = np.linspace(r, 0.0, N_radial+1)
    TH = np.linspace(0.0, np.pi, N_theta+1)

    # Calculate radii of side sections
    R_x = (h-X)*r/h

    # Calculate trig functions
    C_TH = np.cos(TH)
    S_TH = np.sin(TH)

    # Generate points going down the side
    for i in range(N_transverse):
        for j in range(N_theta+1):

            # Determine index
            ind = 1 + j + i*(N_theta+1)

            # x coordinate
            vertices[ind,0] = X[i+1]

            # y coordinate
            vertices[ind,1] = C_TH[j]*R_x[i+1]

            # z coordinate
            vertices[ind,2] = S_TH[j]*R_x[i+1]

    # Get end from which the bottom needs to pick up
    end_of_side = copy.copy(ind)

    # Generate points on bottom (from edge to center)
    for i in range(N_radial-1):
        for j in range(N_theta+1):

            # Determine index
            ind = end_of_side+1 + j + i*(N_theta+1)

            # y coordinate
            vertices[ind,1] = C_TH[j]*R[i+1]

            # z coordinate
            vertices[ind,2] = S_TH[j]*R[i+1]

    # Initialize panels

    # First row at tip
    for i in range(N_theta):

        # Set indices
        panels[i,0] = 0
        panels[i,1] = i+1
        panels[i,2] = i+2

    # Subsequent rows up side and on bottom
    # Each loop iteration will create 2 panels
    for i in range(N_transverse-1+N_radial-1):
        for j in range(N_theta):

            # Determine index of first panel
            ind = N_theta + 2*j + 2*i*N_theta

            # Set indices
            panels[ind,0] = 1 + j + i*(N_theta+1)
            panels[ind,1] = 1 + j + (i+1)*(N_theta+1)
            panels[ind,2] = 1 + j+1 + (i+1)*(N_theta+1)

            # Determine index of second panel
            ind += 1

            # Set indices
            panels[ind,0] = 1 + j + i*(N_theta+1)
            panels[ind,1] = 1 + j+1 + (i+1)*(N_theta+1)
            panels[ind,2] = 1 + j+1 + i*(N_theta+1)

    # Final row on bottom
    for j in range(N_theta):

        # Determine index of panel
        ind = N_panels-N_theta+j

        # Set indices
        panels[ind,0] = N_verts-1
        panels[ind,1] = N_verts-N_theta-1+j
        panels[ind,2] = N_verts-N_theta-2+j

    return vertices, panels
            

def _get_regular_points_and_panels_for_open_right_cone(h, r, N_transverse, N_theta, equal_aspect=True):
    # Generates the points and panels for half of a closed right cone, aligned with the x-axis and its base at the origin.
    # resultant mesh should be mirrored about the xy plane.

    # Determine number of vertices
    N_verts = 1 + N_transverse*(N_theta+1)

    # Determine number of panels
    N_panels = (2*(N_transverse-1)+1)*N_theta

    # Initialize storage
    vertices = np.zeros((N_verts,3))
    panels = np.zeros((N_panels,3), dtype=int)

    # Apex
    vertices[0,0] = h

    # Generate distribution of locations in x, r, and theta
    if equal_aspect:
        X = np.logspace(-1, 0, N_transverse)
        X = (1.0-X[::-1])*h
        X = np.insert(X, 0, 0.0)
    else:
        X = np.linspace(h, 0.0, N_transverse+1)
    TH = np.linspace(0.0, np.pi, N_theta+1)

    # Calculate radii of side sections
    R_x = (h-X)*r/h

    # Calculate trig functions
    C_TH = np.cos(TH)
    S_TH = np.sin(TH)

    # Generate points going down the side
    for i in range(N_transverse):
        for j in range(N_theta+1):

            # Determine index
            ind = 1 + j + i*(N_theta+1)

            # x coordinate
            vertices[ind,0] = X[i+1]

            # y coordinate
            vertices[ind,1] = C_TH[j]*R_x[i+1]

            # z coordinate
            vertices[ind,2] = S_TH[j]*R_x[i+1]

    # Initialize panels

    # First row at tip
    for i in range(N_theta):

        # Set indices
        panels[i,0] = 0
        panels[i,1] = i+1
        panels[i,2] = i+2

    # Subsequent rows up side and on bottom
    # Each loop iteration will create 2 panels
    for i in range(N_transverse-1):
        for j in range(N_theta):

            # Determine index of first panel
            ind = N_theta + 2*j + 2*i*N_theta

            # Set indices
            panels[ind,0] = 1 + j + i*(N_theta+1)
            panels[ind,1] = 1 + j + (i+1)*(N_theta+1)
            panels[ind,2] = 1 + j+1 + (i+1)*(N_theta+1)

            # Determine index of second panel
            ind += 1

            # Set indices
            panels[ind,0] = 1 + j + i*(N_theta+1)
            panels[ind,1] = 1 + j+1 + (i+1)*(N_theta+1)
            panels[ind,2] = 1 + j+1 + i*(N_theta+1)

    return vertices, panels
            

def _get_regular_points_and_panels_for_open_isosceles_right_cone(h, r, N_transverse, N_theta):
    # Generates the points and panels for half of a closed right cone, aligned with the x-axis and its base at the origin.
    # resultant mesh should be mirrored about the xy plane.
    # The number of triangles on each row of the cone increases, making each tri in the mesh isosceles-ish
    # N_theta is the number of triangles in the first row

    # Determine number of panels
    N_panels = N_theta + 2*(N_transverse-1)*N_theta + 2*(N_transverse-2) - 1

    # Initialize storage
    panels = np.zeros((N_panels,3), dtype=int)
    X_v = []
    Y_v = []
    Z_v = []

    # Apex
    X_v.append(h)
    Y_v.append(0.0)
    Z_v.append(0.0)

    # Generate distribution of locations in x
    X = np.linspace(h, 0.0, N_transverse+1)

    # Calculate radii of side sections
    R_x = (h-X)*r/h

    # Generate points going down the side
    i_curr = 0
    for i in range(N_transverse):

        # Get number of theta stations for this slice
        N_theta_i = N_theta + i + 1

        # Get distribution of angles
        TH = np.linspace(0.0, np.pi, N_theta_i)

        # Calculate trig functions
        C_TH = np.cos(TH)
        S_TH = np.sin(TH)

        # Place vertices
        for j in range(N_theta_i):

            # Update index
            i_curr += 1

            # x coordinate
            X_v.append(X[i+1])

            # y coordinate
            Y_v.append(C_TH[j]*R_x[i+1])

            # z coordinate
            Z_v.append(S_TH[j]*R_x[i+1])

    vertices = np.array([X_v, Y_v, Z_v]).T

    # Initialize panels

    panel_0 = []
    panel_1 = []
    panel_2 = []

    # First row at tip
    i_base_corner = 0
    i_forward_corner = 1
    for i in range(N_theta):

        # Update indices
        i_forward_corner += 1
        i_prev_start = 1

        # Set indices
        panel_0.append(i_base_corner)
        panel_1.append(i_forward_corner - 1)
        panel_2.append(i_forward_corner)

    # Subsequent rows up side
    # Each loop iteration will create 2 panels
    for i in range(N_transverse-1):

        # Get number of panels in theta for this slice
        N_theta_i = N_theta + i

        # Set indices
        i_base_corner = i_prev_start
        i_forward_corner += 1

        for j in range(N_theta_i):

            # Set start corner
            if j==0:
                i_prev_start = i_forward_corner

            # Update indices
            i_curr += 1
            i_forward_corner += 1

            # Set indices
            panel_0.append(i_base_corner)
            panel_1.append(i_forward_corner - 1)
            panel_2.append(i_forward_corner)

            # Determine index of second panel
            i_curr += 1

            # Set indices
            panel_0.append(i_base_corner)
            panel_1.append(i_forward_corner)
            panel_2.append(i_base_corner + 1)

            i_base_corner += 1

        # Create last panel
        i_curr += 1
        i_forward_corner += 1

        # Set indices
        panel_0.append(i_base_corner)
        panel_1.append(i_forward_corner - 1)
        panel_2.append(i_forward_corner)

    panels = np.array([panel_0, panel_1, panel_2]).T

    return vertices, panels


def generate_regular_right_cone(filename, h, r, N_transverse, N_theta, N_radial=1, close_base=True, equal_aspect=True, isosceles=False):
    """Generates a mesh of half of a right cone, aligned with the x-axis and its base at the origin.
    The resultant mesh should be mirrored about the xy plane.
    
    Parameters
    ----------
    filename : str
        Name of the file to write the mesh to. Must have '.vtk' extension.

    h : float
        Height.

    r : float
        Base radius.
    
    N_transverse : int
        Number of sections with which to discretize the sides of the cone in the transverse direction.

    N_theta : int
        Number of sections with which to discretize the sides and bottom of the cone in the angular direction.

    N_radial : int, optional
        Number of sections with which to discretize the bottom of the cone in the radial direction. Defaults to 1.

    close_base : logical, optional
        Whether to close the bottom of the cone. Defaults to True.

    equal_aspect : logical, optional
        Whether to space the panels along the length such that the panel aspect ratio remains more constant over the mesh.
        Only available for open cone.
    """

    # Get geometry
    if close_base:
        vertices, panels = _get_regular_points_and_panels_for_closed_right_cone(h, r, N_transverse, N_theta, N_radial)
    else:
        if isosceles:
            vertices, panels = _get_regular_points_and_panels_for_open_isosceles_right_cone(h, r, N_transverse, N_theta)
        else:
            vertices, panels = _get_regular_points_and_panels_for_open_right_cone(h, r, N_transverse, N_theta, equal_aspect=equal_aspect)

    # Export
    _export_vtk(filename, vertices, panels)


def generate_regular_sphere(filename, r, N_azimuth, N_elevation):
    """Generates a mesh of a sphere, aligned with the x-axis and centered on the origin.
    
    Parameters
    ----------
    filename : str
        Name of the file to write the mesh to. Must have '.vtk' extension.

    r : float
        Radius.
    
    N_azimuth : int
        Number of discretizations to make around the circumfrence of the circle (longitudinal divisions).

    N_elevation : int
        Number of discretizations to make from the north to south poles (latitudinal divisions).
    """

    # Get points
    N_verts = (N_elevation-1)*N_azimuth + 2
    vertices = np.zeros((N_verts,3))

    # Poles
    vertices[0,:] = [r, 0.0, 0.0]
    vertices[-1,:] = [-r, 0.0, 0.0]

    # Get angular steps
    thetas = np.linspace(-0.5*np.pi, 0.5*np.pi, N_elevation+1)
    psis = np.linspace(0.0, 2.0*np.pi, N_azimuth+1)

    # Get points
    for i, theta in enumerate(thetas[1:-1]):
        r_i = r*np.cos(theta)
        x = r*np.sin(theta)
        for j, psi in enumerate(psis[:-1]):
            vertices[i*N_azimuth+j+1,0] = x
            vertices[i*N_azimuth+j+1,1] = r_i*np.cos(psi)
            vertices[i*N_azimuth+j+1,2] = r_i*np.sin(psi)

    # Export
    _export_hull_of_points(vertices, filename)
    #_export_vtk(filename, vertices, panels)


def _get_random_points_on_surface_of_sphere(N, r):
    """Generates a set of points randomly distributed across the surface of a sphere.
    
    Parameters
    ----------
    N : integer
        Number of points.
        
    r : float
        Radius of sphere.
        
    Returns
    -------
    ndarray
        Array of points.
    """

    # Initialize
    points = np.zeros((N,3))

    # Get azimuth angles
    psi = np.random.random(N)*2.0*np.pi

    # Get elevation angles (weighted towards equator, so the distribution remains even)
    theta = np.arccos(1.0-2.0*np.random.random(N))

    # Get coordinates
    points[:,0] = r*np.sin(theta)*np.cos(psi)
    points[:,1] = r*np.sin(theta)*np.sin(psi)
    points[:,2] = r*np.cos(theta)

    return points


def _export_hull_of_points(verts, filename, check_normal='sphere'):
    # Takes the given vertices, generates a convex hull, and writes it to a vtk

    # Create convex hull
    hull = ConvexHull(verts)

    # Make sure normal vector points outward
    if check_normal == 'sphere':
        fixed_simplices = []
        for simplex in hull.simplices:

            # Calculate normal and centroid
            centroid = np.sum(verts[simplex,:], axis=0) / 3.0
            normal = np.cross(verts[simplex[1],:] - verts[simplex[0],:], verts[simplex[2],:] - verts[simplex[1],:])

            # Check the normal points outward
            if np.dot(centroid, normal) > 0.0:
                fixed_simplices.append(simplex)
            else:
                fixed_simplices.append(simplex[::-1])

    elif check_normal == 'spindle':
        fixed_simplices = []
        for simplex in hull.simplices:

            # Calculate normal and centroid
            centroid = (verts[simplex[0],:] + verts[simplex[1],:] + verts[simplex[2],:]) / 3.0
            normal = np.cross(verts[simplex[1],:] - verts[simplex[0],:], verts[simplex[2],:] - verts[simplex[0],:])

            # Check the normal points outward
            if np.dot(centroid[1:], normal[1:]) > 0.0:
                fixed_simplices.append(simplex)
            else:
                fixed_simplices.append(simplex[::-1])

    else:
        fixed_simplices = hull.simplices

    # Export mesh
    _export_vtk(filename, verts, np.array(fixed_simplices))


def generate_random_sphere(filename, N, r):
    """Generates a random unstructured mesh of a sphere.
    
    Parameters
    ----------
    filename : str
        Name of the file to write the mesh to. Must have '.vtk' extension.

    N : integer
        Number of vertices.
        
    r : float
        Radius of sphere.
        Array of points.
    """
    
    # Get vertices
    verts = _get_random_points_on_surface_of_sphere(N, r)

    # Export
    _export_hull_of_points(verts, filename)


def _get_random_points_on_surface_of_spindle(N, l, r_of_x):
    # Generates a set of random points (except for 2 at the apexes) on a spindle

    # Initialize
    points = np.zeros((N,3))

    # Get chordwise locations
    x = np.random.random(N-2)

    # Get radii
    r = r_of_x(x)

    # Get asimuth angles
    psi = np.random.random(N-2)*2.0*np.pi

    # Get coordinates
    points[:N-2,0] = x*l
    points[:N-2,1] = l*r*np.sin(psi)
    points[:N-2,2] = l*r*np.cos(psi)

    # Add endpoints
    points[N-2,:] = [0.0, 0.0, 0.0]
    points[N-1,:] = [l, 0.0, 0.0]

    return points


def generate_random_spindle(filename, N, l, r_of_x):
    """Generates a random unstructured mesh of a spindle.
    
    Parameters
    ----------
    filename : str
        Name of the file to write the mesh to. Must have '.vtk' extension.

    N : integer
        Number of vertices.
        
    l : float
        Length of spindle
    
    r_of_x : callable
        Gives the radius as a function of the nondimensional chord position.
    """
    
    # Get vertices
    verts = _get_random_points_on_surface_of_spindle(N, l, r_of_x)

    # Export
    _export_hull_of_points(verts, filename, check_normal='spindle')


def generate_spindle(filename, N_ax, N_theta, l, r_of_x, r_l_ratio=None, cosine_cluster=True):
    """Generates a regularly-paneled spindle aligned with the x-axis.
    
    Parameters
    ----------
    filename : str
        Name of the file to write the mesh to. Must have '.vtk' extension.

    N_ax : integer
        Number of disctreizations (panels) to make in the axial direction.

    N_theta : integer
        Half the number of discretizations (panels) to make in the circumferential direction.
        
    l : float
        Length of spindle
    
    r_of_x : callable or str
        Gives the radius as a function of the **nondimensional** axial position.
        Must be able to accept an array of x locations.
        Alternatively, may be 'SH', in which case a Sears-Haack body will be created.

    r_l_ratio : float, optional
        Maximum radius divided by the length. Required only for r_of_x='SH'.

    cosine_cluster : bool, optional
        Whether to cosine cluster the panels in the axial direction. Defaults to True.
    """

    # Determine numbers of panels and vertices
    N_verts = 2 + N_theta*(N_ax-1)

    # Generate axial distribution
    if cosine_cluster:
        theta_range = np.linspace(np.pi, 0.0, N_ax+1)
        x_range = 0.5*l*(1.0 + np.cos(theta_range))
    else:
        x_range = np.linspace(0.0, l, N_ax+1)

    # Get radial distribution
    if r_of_x == 'SH':
        r_max = r_l_ratio*l
        r_range = r_max*(4.0*(x_range/l)*(1.0 - (x_range/l)))**0.75
    else:
        r_range = r_of_x(x_range/l)

    # Generate circuferential distribution
    theta_range = np.linspace(0.0, 2.0*np.pi, N_theta)

    # Initialize vertex storage
    verts = np.zeros((N_verts,3))

    # Place vertices
    for i, x in enumerate(x_range[1:-1]):
        for j, theta in enumerate(theta_range):

            # Get index of vertex
            ind = 1 + i*N_theta + j

            # Place coordinates
            r = r_range[i+1]
            verts[ind,0] = x
            verts[ind,1] = r*np.cos(theta)
            verts[ind,2] = r*np.sin(theta)

    # Tip
    verts[-1,0] = l

    _export_hull_of_points(verts, filename, check_normal='spindle')


if __name__=="__main__":

    ## Test cone
    #angles = [2.5, 5.0, 10.0, 15.0]
    #for angle in angles:
    #    h = 1.0/np.tan(np.radians(angle))
    #    generate_regular_right_cone('studies/supersonic_cone_flow_study/meshes/cone_{0}_deg_fine.vtk'.format(int(angle)), h, 1.0, 120, 100, close_base=False)
    #h = 1.0/np.tan(np.radians(10.0))
    #generate_regular_right_cone('studies/matrix_solvers/meshes/cone_10_deg_medium.vtk', h, 1.0, 40, 30, close_base=False)
    #generate_regular_right_cone('dev/meshes/half_cone_coarse.vtk', h, 1.0, 100, 6, close_base=False, isosceles=True)

    ## Random spheres
    #Ns = [125, 250, 500, 1000, 2000]
    #labels = ['ultra_coarse', 'coarse', 'medium', 'fine', 'ultra_fine']
    #for N, label in zip(Ns, labels):
    #    for j in range(10):
    #        generate_random_sphere('studies/panel_regularity_sphere_study/meshes/random_sphere_{0}_sample_{1}.vtk'.format(label, j), N, 1.0)

    ## Test random spindle
    #def r_of_x(x):
    #    return 0.05*x*(1.0-x)


    # Regular sphere
    #generate_regular_sphere("dev/meshes/regular_sphere.vtk", 1.0, 40, 20)

    # Sears-Haack
    #generate_spindle('dev/meshes/test_sears_haack.vtk', 100, 100, 1.0, 'SH', 0.037879, cosine_cluster=False)
    def r_of_x(x):
        return 0.2*x*(1.0-x)
    #generate_spindle('studies/supersonic_spindle/meshes/ehlers_spindle_fine.vtk', 80, 80, 1.0, r_of_x, cosine_cluster=True)
    generate_random_spindle("studies/supersonic_spindle/meshes/random_spindle_100.vtk", 100, 1.0, r_of_x)